import { getIngredientsApi } from '@api';
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { TIngredient } from '@utils-types';

//создаем enum (перечисление) для описания различных состояний запроса
enum RequestStatus {
  //начальное состояние, когда запрос еще не начат
  Idle = 'Idle',
  //состояние, когда запрос выполняется
  Loading = 'Loading',
  //состояние, когда запрос успешно завершился
  Success = 'Success',
  //состояние, когда запрос завершился неудачно
  Failed = 'Failed'
}

//
type TIngredientsState = {
  data: TIngredient[];
  status: RequestStatus;
};

//описываем начальное состояние
const initialState: TIngredientsState = {
  data: [],
  status: RequestStatus.Idle
};

//createAsyncThunk — это функция из Redux Toolkit, которая упрощает создание асинхронных действий (thunks) в Redux.
/*Она автоматизирует обработку трех состояний асинхронного запроса: "pending" (ожидание), "fulfilled" (успешное выполнение) и "rejected" (неудача). Это делает управление асинхронными операциями более удобным и упрощает обработку состояний загрузки, успеха и ошибки.*/
/**В Redux Toolkit, createAsyncThunk автоматически создает экшен-креаторы для каждого состояния асинхронного действия: pending, fulfilled и rejected. Это делается для того, чтобы упростить обработку различных состояний асинхронных операций (например, запросов к API). */
export const getIngredients = createAsyncThunk<TIngredient[]>(
  //Строковый идентификатор действия в createAsyncThunk используется для идентификации создаваемого асинхронного действия. Он служит префиксом для создаваемых типов действий (pending, fulfilled, rejected) и помогает Redux однозначно определить, к какому slice состояния относится данное действие.
  //префикс — это строка, используемая для идентификации действия и облегчения его отслеживания в логике приложения
  /*В этом примере 'ingredients/getIngredients' — это строковый идентификатор действия. На его основе Redux Toolkit будет генерировать следующие действия:
  'ingredients/getIngredients/pending'
  'ingredients/getIngredients/fulfilled'
  'ingredients/getIngredients/rejected' 
  Использование такого префикса позволяет легко отслеживать, к какому slice и какому действию относится конкретное состояние или действие.*/
  'ingredients/getIngredients',
  //Вторым аргументом createAsyncThunk является асинхронная функция, которая выполняет запрос и возвращает Promise. Эта функция содержит основную логику для выполнения асинхронной операции, такой как HTTP-запрос к API.
  /*
  Асинхронная функция: Функция getIngredientsApi — это асинхронная функция, которая выполняет HTTP-запрос с помощью fetch. Она возвращает Promise, который разрешается в массив объектов типа TIngredient.
  Обработка ответа: Если ответ успешен (response.ok), функция парсит ответ с помощью response.json() и возвращает данные. Если запрос не успешен, выбрасывается ошибка.
  Передача функции в createAsyncThunk: Асинхронная функция передается в createAsyncThunk как второй аргумент. Когда это действие запускается, Redux Toolkit вызывает эту функцию и автоматически обрабатывает возвращаемый Promise. 
  */
  //Функция, которая "парсит" (или "разбирает") ответ, означает, что она анализирует и обрабатывает полученные данные для извлечения нужной информации или преобразования данных в более удобный формат. В контексте веб-разработки, "парсить ответ" обычно означает обрабатывать данные, полученные от веб-сервера, чтобы сделать их пригодными для использования в приложении.
  getIngredientsApi
);

//Слайс (slice) в Redux Toolkit представляет собой часть состояния (store) и логику, связанную с управлением этой частью состояния.
export const ingredientsSlice = createSlice({
  //строка, которая используется в качестве префикса для всех экшенов, создаваемых этим слайсом
  name: 'ingredients',
  //начальное состояние слайса
  initialState,
  //Объект, содержащий функции-редьюсеры для обработки синхронных действий (или по другому экшены которые они обрабатывают)
  //ключамы в объекте выступают сами экшены
  //Экшен (action) — это объект, который отправляется в хранилище (store) для изменения состояния. Каждый экшен должен иметь, по крайней мере, одно обязательное поле type, которое указывает, какое действие нужно выполнить. Кроме того, экшены могут содержать дополнительные данные в поле payload
  //каждый редюсер принимает два параметра: state - текущее состояние слайса и action - действие которое содержит тип и payload
  //Редьюсер (reducer) — это чистая функция, которая принимает текущее состояние и экшен в качестве аргументов и возвращает новое состояние. Редьюсеры определяют, как состояние приложения должно изменяться в ответ на действия (actions).
  reducers: {},
  //Объект или функция, используемая для обработки дополнительных действий, особенно полезная для работы с асинхронными действиями, созданными с помощью createAsyncThunk., особенно полезно для обработки действий, созданных с помощью createAsyncThunk
  extraReducers: (builder) => {
    //builder: Функция builder предоставляет методы для добавления дополнительных редьюсеров. Это позволяет структурировать код и делать его более читабельным.
    builder
      //addCase — это метод, используемый в extraReducers для обработки дополнительных действий, особенно асинхронных. Он позволяет добавлять обработчики для действий, которые могут быть определены вне данного слайса.
      /*addCase(actionCreator, reducer):
        actionCreator: Экшен-креатор, для которого добавляется обработчик (например, getIngredients.pending).
        reducer: Функция-редьюсер, которая будет вызвана, когда соответствующий экшен будет отправлен. */
      .addCase(getIngredients.pending, (state) => {
        state.status = RequestStatus.Loading;
      })
      .addCase(getIngredients.fulfilled, (state, action) => {
        state.status = RequestStatus.Success;
        state.data = action.payload;
      })
      .addCase(getIngredients.rejected, (state) => {
        state.status = RequestStatus.Failed;
      });
  },
  selectors: {
    selectorIngredientsData: (state: TIngredientsState) => state.data,
    selectorIngredientsStatus: (state: TIngredientsState) => state.status
  }
});

export const selectorIngredients = ingredientsSlice.selectors;
